<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLO Label Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #0a0a0a;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            border: 1px solid #3a3a3a;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }

        .sidebar {
            width: 300px;
            background: #2a2a2a;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #3a3a3a;
        }

        .sidebar-section h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #aaa;
        }

        .class-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .class-btn {
            padding: 10px;
            border: 2px solid #444;
            background: #333;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .class-btn:hover {
            background: #444;
        }

        .class-btn.active {
            border-color: #007bff;
            background: #007bff;
        }

        .annotations-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .annotation-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .annotation-item:hover {
            background: #444;
        }

        .annotation-item.selected {
            background: #007bff;
        }

        .annotation-info {
            flex: 1;
        }

        .annotation-class {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .annotation-coords {
            font-size: 11px;
            color: #aaa;
        }

        .annotation-actions {
            display: flex;
            gap: 8px;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .instructions {
            font-size: 13px;
            color: #aaa;
            line-height: 1.6;
        }

        .instructions ul {
            margin-top: 10px;
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 6px;
        }

        .preview-bar {
            background: #2a2a2a;
            border-top: 1px solid #3a3a3a;
            padding: 10px 20px;
            display: none;
        }

        .preview-bar.show {
            display: block;
        }

        .preview-progress {
            height: 6px;
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 999px;
            overflow: hidden;
            margin: 6px 0 8px;
        }

        .preview-progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #28a745, #2ecc71);
            transition: width 0.2s ease;
        }

        .preview-search-input {
            padding: 4px 8px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #ffffff;
            font-size: 12px;
            width: 200px;
            outline: none;
            transition: border-color 0.2s;
        }

        .preview-search-input:focus {
            border-color: #007bff;
        }

        .preview-search-input::placeholder {
            color: #6c757d;
        }

        .preview-sort-select {
            padding: 4px 8px;
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            color: #ffffff;
            font-size: 12px;
            outline: none;
            transition: border-color 0.2s;
        }

        .preview-sort-select:focus {
            border-color: #007bff;
        }

        .image-preview {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            overflow-y: hidden;
            padding: 5px 0;
            cursor: grab;
            user-select: none;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .image-preview::-webkit-scrollbar {
            display: none;
        }

        .image-preview.dragging {
            cursor: grabbing;
        }

        .preview-item {
            width: 100px;
            height: 100px;
            border: 3px solid #444;
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            flex-shrink: 0;
        }

        .preview-item:hover {
            border-color: #007bff;
            transform: scale(1.05);
        }

        .preview-item.active {
            border-color: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }

        .preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-item .preview-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 10px;
            padding: 2px 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-bar {
            background: #2a2a2a;
            padding: 10px 20px;
            border-top: 1px solid #3a3a3a;
            font-size: 13px;
            color: #aaa;
        }

        .info-field {
            margin-bottom: 10px;
        }

        .info-label {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 14px;
            word-break: break-all;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
        }

        .error {
            color: #dc3545;
            padding: 20px;
            text-align: center;
        }

        .filter-section {
            background: #252525;
        }

        .filter-input {
            width: 100%;
            padding: 8px 12px;
            background: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            font-size: 13px;
            margin-bottom: 10px;
        }

        .filter-input:focus {
            outline: none;
            border-color: #007bff;
        }

        .filter-warning {
            margin-top: 8px;
            color: #dc3545;
            font-size: 12px;
        }

        .filter-group {
            margin-bottom: 15px;
        }

        .filter-label {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 5px;
            display: block;
        }

        .filter-checkboxes {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-bottom: 10px;
            max-height: 180px;
            overflow-y: auto;
            padding-right: 4px;
        }

        .filter-checkbox-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 4px;
            background: #2a2a2a;
            border-radius: 3px;
        }

        .filter-checkbox-item input[type="checkbox"] {
            cursor: pointer;
        }

        .filter-class-search {
            margin: 8px 0 10px;
        }

        .filter-class-search input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            background: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .filter-class-search input[type="text"]:focus {
            outline: none;
            border-color: #007bff;
        }

        .filter-class-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 8px 0 10px;
            min-height: 18px;
        }

        .filter-class-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            background: #2a2a2a;
            border-radius: 999px;
            font-size: 11px;
            color: #e0e0e0;
            cursor: pointer;
            border: 1px solid #3a3a3a;
        }

        .filter-class-chip span {
            opacity: 0.8;
        }

        .filter-range {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .filter-range input[type="number"] {
            width: 60px;
            padding: 6px 8px;
            background: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .filter-range select {
            flex: 1;
            padding: 6px 8px;
            background: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 4px;
            font-size: 12px;
        }

        .filter-stats {
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
            padding: 8px;
            background: #2a2a2a;
            border-radius: 4px;
        }

        .filter-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .filter-toggle:hover {
            color: #007bff;
        }

        .filter-content {
            margin-top: 15px;
        }

        .filter-content.collapsed {
            display: none;
        }

        .btn-clear-filter {
            width: 100%;
            padding: 8px;
            background: #444;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        .btn-clear-filter:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>YOLO Label Editor</h1>
        <div class="header-actions">
            <button class="btn btn-secondary" onclick="previousImage()" id="prevBtn">← Previous</button>
            <span id="imageCounter" style="margin: 0 15px; color: #aaa;"></span>
            <button class="btn btn-secondary" onclick="nextImage()" id="nextBtn">Next →</button>
            <button class="btn btn-secondary" onclick="loadImage()">Reload</button>
            <button class="btn btn-primary" onclick="saveLabels()">Save Labels</button>
        </div>
    </div>

    <div class="main-container">
        <div class="canvas-container" id="canvasContainer">
            <div class="loading" id="loading">Loading...</div>
            <div class="error-message" id="errorMessage"
                style="display: none; color: #dc3545; padding: 20px; text-align: center;"></div>
            <canvas id="canvas"></canvas>
        </div>

        <div class="sidebar">
            <div class="sidebar-section filter-section">
                <div class="filter-toggle" onclick="toggleFilterSection()">
                    <h2>Filter Images</h2>
                    <span id="filterToggleIcon">▶</span>
                </div>
                <div class="filter-content collapsed" id="filterContent">
                    <div class="filter-group">
                        <label class="filter-label">Image Name</label>
                        <input type="text"
                               class="filter-input"
                               id="filterName"
                               placeholder="Search by filename..."
                               autocomplete="off"
                               inputmode="text"
                               oninput="applyFiltersDebounced()">
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">Has Classes</label>
                        <div class="filter-range">
                            <select id="filterClassMode" onchange="applyFilters()">
                                <option value="any">Any</option>
                                <option value="none">None (no labels)</option>
                                <option value="only">Only Selected</option>
                            </select>
                            <select id="filterClassLogic" onchange="applyFilters()">
                                <option value="any">Match Any</option>
                                <option value="all">Match All</option>
                            </select>
                        </div>
                        <div class="filter-class-search">
                            <input type="text"
                                   id="filterClassSearch"
                                   placeholder="Search classes..."
                                   autocomplete="off"
                                   inputmode="text">
                        </div>
                        <div class="filter-class-chips" id="filterClassChips"></div>
                        <div class="filter-checkboxes" id="filterClasses"></div>
                    </div>

                    <div class="filter-group">
                        <label class="filter-label">Label Count</label>
                        <div class="filter-range">
                            <input type="number" id="filterMinLabels" placeholder="Min" min="0" value="0" onchange="applyFilters()">
                            <span>to</span>
                            <input type="number" id="filterMaxLabels" placeholder="Max" min="0" value="" onchange="applyFilters()">
                        </div>
                    </div>

                    <button class="btn-clear-filter" onclick="clearFilters()">Clear All Filters</button>

                <div class="filter-stats" id="filterStats">
                    Showing all images
                </div>
                <div class="filter-warning" id="filterWarning" style="display: none;">
                    Label count min cannot be greater than max
                </div>
            </div>
        </div>

            <div class="sidebar-section">
                <h2>Image Info</h2>
                <div class="info-field">
                    <div class="info-label">Filename</div>
                    <div class="info-value" id="filename">-</div>
                </div>
                <div class="info-field">
                    <div class="info-label">Image Size</div>
                    <div class="info-value" id="imageSize">-</div>
                </div>
            </div>

            <div class="sidebar-section">
                <h2>Select Class <span style="font-size: 12px; color: #aaa;">(Click to change selected)</span></h2>
                <div class="class-selector" id="classSelector"></div>
            </div>

            <div class="sidebar-section">
                <h2>Annotations (<span id="annotationCount">0</span>)</h2>
                <div class="annotations-list" id="annotationsList"></div>
            </div>

            <div class="sidebar-section">
                <h2>Instructions</h2>
                <div class="instructions">
                    <ul>
                        <li>Select a class above</li>
                        <li>Click and drag to create box</li>
                        <li>Polygon mode: click 4 points to create box</li>
                        <li>Click box to select/edit</li>
                        <li>Delete key to remove</li>
                        <li>Drag corners to resize</li>
                        <li><strong>← → or A D keys</strong> to switch images</li>
                        <li><strong>Ctrl Z / Ctrl Shift Z</strong> to undo/redo</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div class="preview-bar" id="previewBar">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <div style="color: #aaa; font-size: 12px;" id="imagePreviewCount">
                Images
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
                <select id="previewSort" class="preview-sort-select" onchange="handlePreviewSortChange()">
                    <option value="name-asc">Name (A-Z)</option>
                    <option value="name-desc">Name (Z-A)</option>
                    <option value="created-desc">Created (newest)</option>
                    <option value="created-asc">Created (oldest)</option>
                </select>
                <input type="text"
                       id="previewSearch"
                       class="preview-search-input"
                       placeholder="Search filename..."
                       oninput="handlePreviewSearch()">
            </div>
        </div>
        <div class="preview-progress">
            <div class="preview-progress-fill" id="previewProgressFill"></div>
        </div>
        <div class="image-preview" id="imagePreview"></div>
    </div>

    <div class="status-bar" id="statusBar">
        Ready
    </div>

    <script>
        // Configuration
        const DEFAULT_CLASSES = ['one', 'two', 'three', 'four', 'five', 'six', 'invalid'];
        const BASE_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#E74C3C'];
        let CLASSES = [...DEFAULT_CLASSES];

        // State
        let image = null;
        let labelData = null;
        let annotations = [];
        let defaultAnnotationType = 'bbox';
        let isRotating = false;
        let rotateState = null;
        let selectedClass = 0;
        let selectedAnnotation = null;
        let isDrawing = false;
        let drawStart = null;
        let currentBox = null;
        let isDragging = false;
        let dragHandle = null;
        let isPanning = false;
        let panStart = null;
        let baseScale = 1; // Scale to fit image to canvas
        let viewScale = 1; // User zoom level
        let viewOffsetX = 0;
        let viewOffsetY = 0;
        let pendingSelection = null;
        let lastHitIndices = [];
        let lastHitCycle = 0;
        let lastHitPoint = null;

        // Multi-image support
        let allImageList = []; // Full unfiltered list
        let imageList = []; // Filtered list (used for navigation)
        let currentImageIndex = 0;
        let basePath = '';
        let imageThumbnails = {}; // Store thumbnails for preview
        let currentLabelPath = ''; // Current label path for saving
        let imageMetaByPath = {};
        let previewDragInitialized = false;
        let previewScrollInitialized = false;
        let previewRenderStart = 0;
        let previewRenderEnd = 0;
        let previewSortMode = 'name-asc';
        let hasUnsavedChanges = false;
        let pendingPreviewCenter = null;
        let previewSearchQuery = ''; // Search query for preview filtering
        let isCreatingObb = false;
        let obbCreatePoints = [];
        let obbPreviewPoint = null;
        let mouseCanvasPoint = null;
        let showCrosshair = false;
        let lastMouseClient = null;
        let previewDragState = {
            isDown: false,
            moved: false,
            startX: 0,
            scrollLeft: 0,
            pointerId: null,
            dragging: false,
            rafId: null,
            lastDeltaX: 0
        };
        const HISTORY_LIMIT = 100;
        let undoStack = [];
        let redoStack = [];
        let historySnapshot = null;

        // Filter support
        let labelCache = {}; // Cache label info for filtering: { imagePath: { classes: [0,1,2], count: 3 } }
        let filterActive = false;
        let filterDebounceTimer = null;

        // Canvas
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);

        // Support both old (full paths) and new (base + relative) format
        const imagePath = urlParams.get('image');
        const labelPath = urlParams.get('label');
        basePath = urlParams.get('base') || '';
        const relativeImage = urlParams.get('img');
        const relativeLabel = urlParams.get('lbl');
        const folderParam = urlParams.get('folder');

        // Support multiple images (comma-separated)
        const imageListParam = urlParams.get('images');
        if (imageListParam) {
            allImageList = imageListParam.split(',').map(img => img.trim());
        } else if (relativeImage) {
            allImageList = [relativeImage];
        } else if (imagePath) {
            allImageList = [imagePath];
        }
        imageList = [...allImageList]; // Initialize filtered list

        // Load images from folder if folder parameter is provided
        async function loadImagesFromFolder() {
            if (!folderParam || !basePath) {
                return false;
            }

            try {
                showStatus('Loading images from folder...');
                const response = await fetch(`/api/label-editor/list-folder?basePath=${encodeURIComponent(basePath)}&folder=${encodeURIComponent(folderParam)}`);

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to load folder');
                }

                const data = await response.json();
                allImageList = data.images;
                imageMetaByPath = data.imageMeta || {};
                imageList = [...allImageList]; // Initialize filtered list

                if (imageList.length === 0) {
                    showError(`No images found in folder: ${folderParam}`);
                    return false;
                }

                applyPreviewSort(false);
                showStatus(`Loaded ${imageList.length} images from folder`);
                return true;
            } catch (err) {
                showError(`Error loading folder: ${err.message}`);
                return false;
            }
        }

        // Initialize
        async function init() {
            // Load from folder if folder parameter is provided
            if (folderParam) {
                const loaded = await loadImagesFromFolder();
                if (!loaded) return;
            }

            if (imageList.length === 0) {
                showError('Missing image path parameters');
                return;
            }

            applyPreviewSort(false);
            await loadClassNames();
            setupClassSelector();
            setupFilterUI();
            setupEventListeners();
            updateNavigationButtons();
            setupImagePreview();
            await loadImage();
        }

        // === FILTER FUNCTIONS ===

        // Debounced version for text input
        function applyFiltersDebounced() {
            if (filterDebounceTimer) {
                clearTimeout(filterDebounceTimer);
            }
            filterDebounceTimer = setTimeout(() => {
                applyFilters();
            }, 300); // Wait 300ms after user stops typing
        }

        function setupFilterUI() {
            // Setup class filter checkboxes
            const filterClassesDiv = document.getElementById('filterClasses');
            filterClassesDiv.innerHTML = ''; // Clear any existing content

            CLASSES.forEach((cls, idx) => {
                const item = document.createElement('div');
                item.className = 'filter-checkbox-item';
                item.dataset.className = cls.toLowerCase();

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `filter-class-${idx}`;
                checkbox.value = idx;
                checkbox.onchange = () => {
                    console.log(`Checkbox ${cls} (${idx}) changed to ${checkbox.checked}`);
                    updateSelectedClassChips();
                    applyFilters();
                };

                const label = document.createElement('label');
                label.htmlFor = `filter-class-${idx}`;
                label.textContent = cls;
                label.style.cursor = 'pointer';
                label.style.color = getClassColor(idx);

                item.appendChild(checkbox);
                item.appendChild(label);
                filterClassesDiv.appendChild(item);
            });

            setupClassSearchInput();
            updateSelectedClassChips();
            console.log('Filter UI setup complete. Created checkboxes for:', CLASSES);
        }

        function setupClassSearchInput() {
            const classSearchInput = document.getElementById('filterClassSearch');
            if (!classSearchInput) {
                return;
            }

            classSearchInput.oninput = () => {
                const query = classSearchInput.value.trim().toLowerCase();
                filterClassListBySearch(query);
            };
        }

        function filterClassListBySearch(query) {
            const filterClassesDiv = document.getElementById('filterClasses');
            if (!filterClassesDiv) {
                return;
            }

            const items = filterClassesDiv.querySelectorAll('.filter-checkbox-item');
            items.forEach(item => {
                const matches = !query || item.dataset.className.includes(query);
                item.style.display = matches ? 'flex' : 'none';
            });
        }

        function updateSelectedClassChips() {
            const classChips = document.getElementById('filterClassChips');
            if (!classChips) {
                return;
            }

            classChips.innerHTML = '';
            CLASSES.forEach((cls, idx) => {
                const checkbox = document.getElementById(`filter-class-${idx}`);
                if (checkbox && checkbox.checked) {
                    const chip = document.createElement('div');
                    chip.className = 'filter-class-chip';
                    chip.style.borderColor = getClassColor(idx);
                    chip.innerHTML = `${cls} <span>×</span>`;
                    chip.onclick = () => {
                        checkbox.checked = false;
                        updateSelectedClassChips();
                        applyFilters();
                    };
                    classChips.appendChild(chip);
                }
            });
        }

        function getClassColor(index) {
            if (BASE_COLORS[index]) {
                return BASE_COLORS[index];
            }
            const hue = (index * 47) % 360;
            return `hsl(${hue}, 70%, 55%)`;
        }

        async function loadClassNames() {
            const classBasePath = resolveClassBasePath();
            if (!classBasePath) {
                CLASSES = [...DEFAULT_CLASSES];
                return;
            }

            try {
                const response = await fetch(`/api/label-editor/classes?basePath=${encodeURIComponent(classBasePath)}`);
                if (!response.ok) {
                    throw new Error('Failed to load class names');
                }
                const data = await response.json();
                if (Array.isArray(data.classes) && data.classes.length > 0) {
                    CLASSES = data.classes;
                } else {
                    CLASSES = [...DEFAULT_CLASSES];
                }
            } catch (error) {
                console.warn('Failed to load class names:', error);
                CLASSES = [...DEFAULT_CLASSES];
            }
        }

        function resolveClassBasePath() {
            if (basePath) {
                return basePath;
            }
            if (imagePath && imagePath.includes('/images/')) {
                return imagePath.split('/images/')[0];
            }
            if (allImageList.length > 0 && allImageList[0].includes('/images/')) {
                return allImageList[0].split('/images/')[0];
            }
            return '';
        }

        function toggleFilterSection() {
            const content = document.getElementById('filterContent');
            const icon = document.getElementById('filterToggleIcon');

            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                icon.textContent = '▼';
            } else {
                content.classList.add('collapsed');
                icon.textContent = '▶';
            }
        }

        // Load metadata from backend for all images (or batch)
        async function loadMetadataFromBackend(imagePaths) {
            try {
                const response = await fetch('/api/label-editor/get-metadata', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        basePath: basePath,
                        images: imagePaths
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to load metadata');
                }

                const data = await response.json();

                // Merge into cache
                Object.assign(labelCache, data.metadata);

                return data.metadata;
            } catch (err) {
                console.error('Error loading metadata:', err);
                return {};
            }
        }

        async function getLabelInfo(imagePath) {
            // Check cache first
            if (labelCache[imagePath]) {
                return labelCache[imagePath];
            }

            // Load from backend
            const metadata = await loadMetadataFromBackend([imagePath]);
            return metadata[imagePath] || { classes: [], count: 0 };
        }

        async function applyFilters() {
            try {
                showStatus('Applying filters...');

                clearFilterWarning();

                // Get filter values
                const nameFilter = document.getElementById('filterName').value.trim();
                const classMode = document.getElementById('filterClassMode').value;
                const classLogic = document.getElementById('filterClassLogic').value;
                const minLabels = parseInt(document.getElementById('filterMinLabels').value) || 0;
                const maxLabelsInput = document.getElementById('filterMaxLabels').value.trim();
                const maxLabels = maxLabelsInput ? parseInt(maxLabelsInput) : null;

                if (maxLabels !== null && minLabels > maxLabels) {
                    showFilterWarning('Label count min cannot be greater than max');
                    return;
                }

                // Get selected classes
                const selectedClasses = [];
                CLASSES.forEach((cls, idx) => {
                    const checkbox = document.getElementById(`filter-class-${idx}`);
                    if (checkbox && checkbox.checked) {
                        selectedClasses.push(idx);
                    }
                });

                console.log('Filter criteria:', {
                    nameFilter,
                    classMode,
                    classLogic,
                    minLabels,
                    maxLabels,
                    selectedClasses
                });

                if (classMode === 'only' && selectedClasses.length === 0) {
                    showFilterWarning('Select classes for "Only Selected" mode');
                    return;
                }

                // Check if any filter is active
                const hasActiveFilter = nameFilter || selectedClasses.length > 0 || minLabels > 0 || maxLabels !== null || classMode !== 'any';

                if (!hasActiveFilter) {
                    // No filters active, show all
                    imageList = sortImageList(allImageList);
                    filterActive = false;
                    updateFilterStats();
                    currentImageIndex = 0;
                    await loadImage();
                    updateNavigationButtons();
                    updateImagePreview();
                    showStatus('No filters active');
                    return;
                }

                // Call backend to filter images
                const response = await fetch('/api/label-editor/filter-images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        basePath: basePath,
                        images: allImageList,
                        filters: {
                            nameFilter: nameFilter,
                            selectedClasses: selectedClasses,
                            classMode: classMode,
                            classLogic: classLogic,
                            minLabels: minLabels,
                            maxLabels: maxLabels !== null ? maxLabels : undefined
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to filter images');
                }

                const data = await response.json();
                const filteredImages = data.filteredImages;

                console.log(`Filtered ${data.totalCount} images down to ${data.filteredCount}`);

                // Update image list
                const previousImage = imageList[currentImageIndex];
                imageList = filteredImages;
                imageList = sortImageList(imageList);
                filterActive = true;

                // Update stats
                updateFilterStats();

                // Reset to first image if current index is out of bounds
                if (previousImage && imageList.includes(previousImage)) {
                    currentImageIndex = imageList.indexOf(previousImage);
                } else if (currentImageIndex >= imageList.length) {
                    currentImageIndex = 0;
                }

                // Reload UI
                if (imageList.length > 0) {
                    await loadImage();
                    updateNavigationButtons();
                    updateImagePreview();
                    showStatus(`Found ${imageList.length} matching images`);
                } else {
                    showError('No images match the current filters');
                }

            } catch (error) {
                console.error('Error applying filters:', error);
                showError(`Filter error: ${error.message}`);
            }
        }

        function updateFilterStats() {
            const stats = document.getElementById('filterStats');
            const previewCount = document.getElementById('imagePreviewCount');

            if (filterActive) {
                stats.textContent = `Showing ${imageList.length} of ${allImageList.length} images`;
                stats.style.color = '#007bff';
                previewCount.innerHTML = `Images (<span style="color: #007bff;">${imageList.length}</span> of ${allImageList.length})`;
            } else {
                stats.textContent = `Showing all ${allImageList.length} images`;
                stats.style.color = '#aaa';
                previewCount.textContent = `Images (${allImageList.length})`;
            }

            updatePreviewProgress();
        }

        function updatePreviewProgress() {
            const fill = document.getElementById('previewProgressFill');
            if (!fill || imageList.length === 0) {
                if (fill) {
                    fill.style.width = '0%';
                }
                return;
            }

            const current = Math.min(imageList.length, Math.max(1, currentImageIndex + 1));
            const percent = (current / imageList.length) * 100;
            fill.style.width = `${percent.toFixed(2)}%`;
        }

        function showFilterWarning(message) {
            const warning = document.getElementById('filterWarning');
            if (!warning) {
                return;
            }

            warning.textContent = message;
            warning.style.display = 'block';
        }

        function clearFilterWarning() {
            const warning = document.getElementById('filterWarning');
            if (!warning) {
                return;
            }

            warning.style.display = 'none';
        }

        function clearFilters() {
            // Clear all filter inputs
            document.getElementById('filterName').value = '';
            document.getElementById('filterClassMode').value = 'any';
            document.getElementById('filterClassLogic').value = 'any';
            const classSearchInput = document.getElementById('filterClassSearch');
            if (classSearchInput) {
                classSearchInput.value = '';
                filterClassListBySearch('');
            }
            document.getElementById('filterMinLabels').value = '0';
            document.getElementById('filterMaxLabels').value = '';

            // Clear preview search
            const previewSearchInput = document.getElementById('previewSearch');
            if (previewSearchInput) {
                previewSearchInput.value = '';
                previewSearchQuery = '';
            }

            // Uncheck all class filters
            CLASSES.forEach((cls, idx) => {
                const checkbox = document.getElementById(`filter-class-${idx}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });

            updateSelectedClassChips();

            // Reset to all images
            imageList = sortImageList(allImageList);
            filterActive = false;
            currentImageIndex = 0;

            // Update UI
            updateFilterStats();
            clearFilterWarning();
            loadImage();
            updateNavigationButtons();
            updateImagePreview();
            showStatus('Filters cleared');
        }

        // === END FILTER FUNCTIONS ===


        function setupImagePreview() {
            if (allImageList.length > 1) {
                document.getElementById('previewBar').classList.add('show');
                updateFilterStats();
            }
            const sortSelect = document.getElementById('previewSort');
            if (sortSelect) {
                sortSelect.value = previewSortMode;
            }
        }

        function sortImageList(list) {
            const sorted = [...list];
            const nameCompare = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
            const createdCompare = (a, b) => {
                const aMeta = imageMetaByPath[a];
                const bMeta = imageMetaByPath[b];
                const aTime = aMeta ? aMeta.ctimeMs : null;
                const bTime = bMeta ? bMeta.ctimeMs : null;
                if (aTime !== null && bTime !== null && aTime !== bTime) {
                    return aTime - bTime;
                }
                return nameCompare(a, b);
            };

            if (previewSortMode === 'created-desc') {
                sorted.sort((a, b) => createdCompare(b, a));
                return sorted;
            }

            if (previewSortMode === 'created-asc') {
                sorted.sort((a, b) => createdCompare(a, b));
                return sorted;
            }

            if (previewSortMode === 'name-desc') {
                sorted.sort((a, b) => nameCompare(b, a));
                return sorted;
            }

            sorted.sort((a, b) => nameCompare(a, b));
            return sorted;
        }

        function applyPreviewSort(keepSelection = true) {
            const currentImage = imageList[currentImageIndex];
            allImageList = sortImageList(allImageList);
            imageList = sortImageList(imageList);
            if (keepSelection && currentImage && imageList.includes(currentImage)) {
                currentImageIndex = imageList.indexOf(currentImage);
            } else if (currentImageIndex >= imageList.length) {
                currentImageIndex = 0;
            }
        }

        function handlePreviewSortChange() {
            const select = document.getElementById('previewSort');
            previewSortMode = select.value;
            applyPreviewSort(true);
            updateNavigationButtons();
            updateImagePreview();
        }

        function handlePreviewSearch() {
            const searchInput = document.getElementById('previewSearch');
            previewSearchQuery = searchInput.value.toLowerCase().trim();

            // Apply the search filter to preview items
            const previewContainer = document.getElementById('imagePreview');
            const previewItems = previewContainer.querySelectorAll('.preview-item');

            let visibleCount = 0;
            previewItems.forEach(item => {
                const index = parseInt(item.dataset.previewIndex);
                const imagePath = imageList[index];
                const filename = imagePath.split('/').pop().toLowerCase();

                if (previewSearchQuery === '' || filename.includes(previewSearchQuery)) {
                    item.style.display = 'flex';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });

            // Update count display
            const countDisplay = document.getElementById('imagePreviewCount');
            if (previewSearchQuery) {
                const totalInFilter = imageList.length;
                if (filterActive) {
                    countDisplay.innerHTML = `Images (<span style="color: #007bff;">${visibleCount}</span> of <span style="color: #007bff;">${totalInFilter}</span> of ${allImageList.length})`;
                } else {
                    countDisplay.innerHTML = `Images (<span style="color: #007bff;">${visibleCount}</span> of ${totalInFilter})`;
                }
            } else {
                // No search, restore normal display
                if (filterActive) {
                    countDisplay.innerHTML = `Images (<span style="color: #007bff;">${imageList.length}</span> of ${allImageList.length})`;
                } else {
                    countDisplay.textContent = `Images (${allImageList.length})`;
                }
            }
        }

        async function updateImagePreview() {
            // Show preview bar if there are multiple images in total (even if filtered to 1)
            if (allImageList.length <= 1) return;

            const previewContainer = document.getElementById('imagePreview');
            previewContainer.innerHTML = '';

            // If no images in filtered list, show message
            if (imageList.length === 0) {
                previewContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #aaa;">No matching images</div>';
                return;
            }

            // Create a wrapper for thumbnails to ensure horizontal layout
            const thumbnailsWrapper = document.createElement('div');
            thumbnailsWrapper.style.cssText = 'display: flex; gap: 8px;';

            // Only load 25 thumbnails at a time (12 before, current, 12 after)
            const THUMBNAIL_WINDOW = 25;
            const halfWindow = Math.floor(THUMBNAIL_WINDOW / 2);

            // Calculate range to display
            let startIdx = Math.max(0, currentImageIndex - halfWindow);
            let endIdx = Math.min(imageList.length, currentImageIndex + halfWindow + 1);

            // Adjust if we're near the start or end
            if (endIdx - startIdx < THUMBNAIL_WINDOW) {
                if (startIdx === 0) {
                    endIdx = Math.min(imageList.length, THUMBNAIL_WINDOW);
                } else if (endIdx === imageList.length) {
                    startIdx = Math.max(0, imageList.length - THUMBNAIL_WINDOW);
                }
            }

            previewRenderStart = startIdx;
            previewRenderEnd = endIdx;

            for (let i = startIdx; i < endIdx; i++) {
                thumbnailsWrapper.appendChild(createPreviewItem(i));
            }

            // Append thumbnails wrapper to container
            previewContainer.appendChild(thumbnailsWrapper);
            setupPreviewDrag();
            setupPreviewInfiniteScroll();
            applyPendingPreviewCenter();

            // Reapply search filter if there is one
            if (previewSearchQuery) {
                handlePreviewSearch();
            }
        }

        function createPreviewItem(index) {
            const imagePath = imageList[index]; // Get the actual image path from filtered list

            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';
            previewItem.dataset.previewIndex = index;
            if (index === currentImageIndex) {
                previewItem.classList.add('active');
            }

            // Create image element
            const img = document.createElement('img');
            img.draggable = false;

            // Use image path as cache key instead of index
            if (imageThumbnails[imagePath]) {
                img.src = imageThumbnails[imagePath];
            } else {
                img.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><rect width="80" height="80" fill="%23333"/><text x="50%" y="50%" text-anchor="middle" fill="%23aaa" font-size="12">Loading...</text></svg>';

                // Load thumbnail asynchronously
                loadThumbnail(index).then(dataUrl => {
                    imageThumbnails[imagePath] = dataUrl; // Cache by path, not index
                    img.src = dataUrl;
                });
            }

            const label = document.createElement('div');
            label.className = 'preview-label';
            const filename = imagePath.split('/').pop();

            // Show filename intelligently - if too long, show end part (usually has unique number)
            if (filename.length > 15) {
                label.textContent = '...' + filename.slice(-12);
                label.title = filename; // Show full name on hover
            } else {
                label.textContent = filename;
            }

            previewItem.appendChild(img);
            previewItem.appendChild(label);

            previewItem.onclick = async () => {
                if (previewDragState.moved) {
                    previewDragState.moved = false;
                    return;
                }
                if (currentImageIndex !== index) {
                    await saveLabels(false);
                    currentImageIndex = index;
                    await loadImage();
                    updateNavigationButtons();
                    requestPreviewCenter(index, true);
                    updateImagePreview();
                }
            };

            // Auto-scroll to active item
            if (index === currentImageIndex) {
                setTimeout(() => {
                    if (!pendingPreviewCenter) {
                        requestPreviewCenter(index, false);
                    }
                    applyPendingPreviewCenter();
                }, 0);
            }

            return previewItem;
        }

        function requestPreviewCenter(index, animate) {
            pendingPreviewCenter = { index, animate };
        }

        function applyPendingPreviewCenter() {
            if (!pendingPreviewCenter) {
                centerPreviewIndex(currentImageIndex, false);
                return;
            }

            const { index, animate } = pendingPreviewCenter;
            pendingPreviewCenter = null;
            centerPreviewIndex(index, animate);
        }

        function centerPreviewIndex(index, animate) {
            const previewContainer = document.getElementById('imagePreview');
            if (!previewContainer) {
                return;
            }

            const target = previewContainer.querySelector(`[data-preview-index="${index}"]`);
            if (!target) {
                return;
            }

            centerPreviewItem(target, animate);
        }

        function setupPreviewInfiniteScroll() {
            if (previewScrollInitialized) {
                return;
            }

            const previewContainer = document.getElementById('imagePreview');
            if (!previewContainer) {
                return;
            }

            let scrollRaf = null;
            const threshold = 80;
            const batchSize = 12;

            const onScroll = () => {
                if (scrollRaf !== null) {
                    return;
                }

                scrollRaf = requestAnimationFrame(() => {
                    scrollRaf = null;
                    const maxScroll = previewContainer.scrollWidth - previewContainer.clientWidth;
                    const wrapper = previewContainer.firstElementChild;
                    if (!wrapper) {
                        return;
                    }

                    if (previewContainer.scrollLeft < threshold && previewRenderStart > 0) {
                        const previousStart = previewRenderStart;
                        const newStart = Math.max(0, previewRenderStart - batchSize);
                        const prevScrollWidth = previewContainer.scrollWidth;
                        const fragment = document.createDocumentFragment();
                        for (let i = newStart; i < previousStart; i++) {
                            fragment.appendChild(createPreviewItem(i));
                        }
                        wrapper.insertBefore(fragment, wrapper.firstChild);
                        const newScrollWidth = previewContainer.scrollWidth;
                        previewContainer.scrollLeft += newScrollWidth - prevScrollWidth;
                        previewRenderStart = newStart;

                        // Apply search filter to new items
                        if (previewSearchQuery) {
                            handlePreviewSearch();
                        }
                    }

                    if (maxScroll - previewContainer.scrollLeft < threshold && previewRenderEnd < imageList.length) {
                        const newEnd = Math.min(imageList.length, previewRenderEnd + batchSize);
                        for (let i = previewRenderEnd; i < newEnd; i++) {
                            wrapper.appendChild(createPreviewItem(i));
                        }
                        previewRenderEnd = newEnd;

                        // Apply search filter to new items
                        if (previewSearchQuery) {
                            handlePreviewSearch();
                        }
                    }
                });
            };

            previewContainer.addEventListener('scroll', onScroll);
            previewScrollInitialized = true;
        }

        function centerPreviewItem(previewItem, animate) {
            const previewContainer = document.getElementById('imagePreview');
            if (!previewContainer || !previewItem) {
                return;
            }

            const containerRect = previewContainer.getBoundingClientRect();
            const itemRect = previewItem.getBoundingClientRect();
            const currentScroll = previewContainer.scrollLeft;
            const targetScroll = currentScroll + (itemRect.left - containerRect.left) - (containerRect.width / 2) + (itemRect.width / 2);
            const maxScroll = previewContainer.scrollWidth - previewContainer.clientWidth;
            const clampedTarget = Math.max(0, Math.min(maxScroll, targetScroll));

            if (!animate) {
                previewContainer.scrollLeft = clampedTarget;
                return;
            }

            smoothScrollTo(previewContainer, clampedTarget, 250);
        }

        function smoothScrollTo(container, target, durationMs) {
            const start = container.scrollLeft;
            const distance = target - start;
            const startTime = performance.now();

            const step = (now) => {
                const elapsed = now - startTime;
                const t = Math.min(1, elapsed / durationMs);
                const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                container.scrollLeft = start + distance * eased;
                if (t < 1) {
                    requestAnimationFrame(step);
                }
            };

            requestAnimationFrame(step);
        }

        function setupPreviewDrag() {
            if (previewDragInitialized) {
                return;
            }

            const previewContainer = document.getElementById('imagePreview');
            if (!previewContainer) {
                return;
            }

            previewContainer.addEventListener('wheel', (event) => {
                event.preventDefault();
                const delta = Math.abs(event.deltaX) > Math.abs(event.deltaY) ? event.deltaX : event.deltaY;
                previewContainer.scrollLeft += delta;
            }, { passive: false });

            previewContainer.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            previewContainer.addEventListener('pointerdown', (event) => {
                if (event.button !== 0) {
                    return;
                }

                previewDragState.isDown = true;
                previewDragState.moved = false;
                previewDragState.dragging = false;
                previewDragState.startX = event.clientX;
                previewDragState.scrollLeft = previewContainer.scrollLeft;
                previewDragState.pointerId = event.pointerId;
                previewDragState.lastDeltaX = 0;
                previewContainer.classList.add('dragging');
            });

            previewContainer.addEventListener('pointermove', (event) => {
                if (!previewDragState.isDown) {
                    return;
                }

                const deltaX = event.clientX - previewDragState.startX;
                if (Math.abs(deltaX) > 5) {
                    previewDragState.moved = true;
                    if (!previewDragState.dragging) {
                        previewDragState.dragging = true;
                        previewContainer.setPointerCapture(previewDragState.pointerId);
                    }
                }
                previewDragState.lastDeltaX = deltaX;
                if (previewDragState.rafId === null) {
                    previewDragState.rafId = requestAnimationFrame(() => {
                        previewContainer.scrollLeft = previewDragState.scrollLeft - previewDragState.lastDeltaX;
                        previewDragState.rafId = null;
                    });
                }
            });

            const stopDrag = (event) => {
                if (!previewDragState.isDown) {
                    return;
                }

                previewDragState.isDown = false;
                previewDragState.dragging = false;
                if (previewDragState.rafId !== null) {
                    cancelAnimationFrame(previewDragState.rafId);
                    previewDragState.rafId = null;
                }
                previewContainer.classList.remove('dragging');
                if (previewDragState.pointerId !== null) {
                    previewContainer.releasePointerCapture(previewDragState.pointerId);
                    previewDragState.pointerId = null;
                }
            };

            previewContainer.addEventListener('pointerup', stopDrag);
            previewContainer.addEventListener('pointercancel', stopDrag);
            previewContainer.addEventListener('pointerleave', () => {
                if (previewDragState.isDown) {
                    previewDragState.isDown = false;
                    previewContainer.classList.remove('dragging');
                }
            });

            previewContainer.addEventListener('click', (event) => {
                if (previewDragState.moved) {
                    event.preventDefault();
                    event.stopPropagation();
                    previewDragState.moved = false;
                }
            }, true);

            previewDragInitialized = true;
        }

        async function loadThumbnail(index) {
            try {
                const imagePath = imageList[index];

                // Use direct image URL (much faster than base64)
                if (basePath) {
                    return `/api/image?basePath=${encodeURIComponent(basePath)}&relativePath=${encodeURIComponent(imagePath)}`;
                } else {
                    return `/api/image?fullPath=${encodeURIComponent(imagePath)}`;
                }
            } catch (error) {
                console.error('Failed to load thumbnail:', error);
                return 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="80"><rect width="80" height="80" fill="%23333"/></svg>';
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const counter = document.getElementById('imageCounter');

            if (imageList.length > 1) {
                counter.textContent = `${currentImageIndex + 1} / ${imageList.length}`;
                prevBtn.disabled = currentImageIndex === 0;
                nextBtn.disabled = currentImageIndex === imageList.length - 1;
            } else {
                counter.style.display = 'none';
                prevBtn.style.display = 'none';
                nextBtn.style.display = 'none';
            }

            updatePreviewProgress();
        }

        async function previousImage() {
            if (currentImageIndex > 0) {
                await saveLabels(false); // Save current before switching
                currentImageIndex--;
                await loadImage();
                updateNavigationButtons();
                updateImagePreview();
            }
        }

        async function nextImage() {
            if (currentImageIndex < imageList.length - 1) {
                await saveLabels(false); // Save current before switching
                currentImageIndex++;
                await loadImage();
                updateNavigationButtons();
                updateImagePreview();
            }
        }

        function setupClassSelector() {
            const selector = document.getElementById('classSelector');
            selector.innerHTML = '';
            CLASSES.forEach((cls, idx) => {
                const btn = document.createElement('button');
                btn.className = 'class-btn';
                btn.textContent = cls;
                btn.style.borderColor = getClassColor(idx);
                btn.onclick = () => selectClass(idx);
                if (idx === 0) btn.classList.add('active');
                selector.appendChild(btn);
            });
        }

        function updateClassSelector() {
            // Highlight the class of the selected annotation
            document.querySelectorAll('.class-btn').forEach((btn, idx) => {
                if (selectedAnnotation !== null) {
                    btn.classList.toggle('active', idx === annotations[selectedAnnotation].class);
                } else {
                    btn.classList.toggle('active', idx === selectedClass);
                }
            });
        }

        function selectClass(classIdx) {
            // If an annotation is selected, change its class
            if (selectedAnnotation !== null) {
                changeAnnotationClass(selectedAnnotation, classIdx);
            }

            // Update selected class for new annotations
            selectedClass = classIdx;
            document.querySelectorAll('.class-btn').forEach((btn, idx) => {
                btn.classList.toggle('active', idx === classIdx);
            });
        }

        async function loadImage() {
            try {
                showStatus('Loading image...');

                // Reset UI state
                document.getElementById('errorMessage').style.display = 'none';
                document.getElementById('loading').style.display = 'block';
                document.getElementById('canvas').style.display = 'none';

                // Get current image path
                const currentImage = imageList[currentImageIndex];
                const currentLabel = currentImage.replace('images/', 'labels/').replace(/\.(jpg|jpeg|png)$/i, '.txt');

                // Store current label path for saving
                currentLabelPath = currentLabel;

                // Build image URL for direct loading (much faster than base64)
                let imageUrl;
                if (basePath) {
                    imageUrl = `/api/image?basePath=${encodeURIComponent(basePath)}&relativePath=${encodeURIComponent(currentImage)}`;
                } else {
                    imageUrl = `/api/image?fullPath=${encodeURIComponent(currentImage)}`;
                }

                // Build label URL
                let labelUrl;
                if (basePath) {
                    labelUrl = `/api/label-editor/load-label?basePath=${encodeURIComponent(basePath)}&relativeLabel=${encodeURIComponent(currentLabel)}`;
                } else {
                    labelUrl = `/api/label-editor/load-label?label=${encodeURIComponent(currentLabel)}`;
                }

                // Load image and label in parallel for better performance
                const [labelResponse] = await Promise.all([
                    fetch(labelUrl),
                    // Image loading is handled separately through Image object
                ]);

                const labelResult = await labelResponse.json();
                labelData = labelResult.labelContent || '';
                annotations = parseLabelData(labelData);
                defaultAnnotationType = annotations.some(ann => ann.type === 'obb') ? 'obb' : 'bbox';
                setUnsavedChanges(false);
                undoStack = [];
                redoStack = [];
                historySnapshot = null;

                // Cache label info for filtering
                const classes = [...new Set(annotations.map(ann => ann.class))];
                labelCache[currentImage] = {
                    classes: classes,
                    count: annotations.length
                };

                // Load image directly via URL (browser caching works)
                image = new Image();
                image.onload = () => {
                    setupCanvas();
                    document.getElementById('loading').style.display = 'none';
                    canvas.style.display = 'block';
                    showStatus('Ready');
                    updateUI();

                    // Preload adjacent images for faster navigation
                    preloadAdjacentImages();
                };
                image.onerror = () => {
                    showError('Failed to load image');
                };
                image.src = imageUrl;

                const filename = currentImage.split('/').pop();
                document.getElementById('filename').textContent = filename;

                // Update image preview
                updateImagePreview();

            } catch (error) {
                showError(error.message);
            }
        }

        // Preload next and previous images for instant navigation
        function preloadAdjacentImages() {
            const PRELOAD_COUNT = 20;
            const preloadIndexes = [];

            // Preload images around current position
            // Prioritize forward navigation (more images ahead than behind)
            const backwardCount = Math.floor(PRELOAD_COUNT * 0.3); // 30% backward (6 images)
            const forwardCount = PRELOAD_COUNT - backwardCount;    // 70% forward (14 images)

            // Add backward images
            for (let i = 1; i <= backwardCount; i++) {
                const idx = currentImageIndex - i;
                if (idx >= 0) {
                    preloadIndexes.push(idx);
                }
            }

            // Add forward images
            for (let i = 1; i <= forwardCount; i++) {
                const idx = currentImageIndex + i;
                if (idx < imageList.length) {
                    preloadIndexes.push(idx);
                }
            }

            // Preload all images in the list
            preloadIndexes.forEach(idx => {
                const imgPath = imageList[idx];
                const img = new Image();

                if (basePath) {
                    img.src = `/api/image?basePath=${encodeURIComponent(basePath)}&relativePath=${encodeURIComponent(imgPath)}`;
                } else {
                    img.src = `/api/image?fullPath=${encodeURIComponent(imgPath)}`;
                }

                // Optional: Add to cache tracking if needed
                img.onload = () => {
                    // Image is now in browser cache
                };
            });

            // Log preloading info (can be removed in production)
            console.log(`Preloading ${preloadIndexes.length} images around index ${currentImageIndex}`);
        }

        function orderPointsClockwiseFromTopLeft(points) {
            const cx = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const cy = points.reduce((sum, p) => sum + p.y, 0) / points.length;

            const withAngle = points.map(p => ({
                x: p.x,
                y: p.y,
                angle: Math.atan2(p.y - cy, p.x - cx)
            }));

            // Sort clockwise
            withAngle.sort((a, b) => b.angle - a.angle);

            // Rotate so the first point is top-left (min y, then min x)
            let startIndex = 0;
            for (let i = 1; i < withAngle.length; i++) {
                if (
                    withAngle[i].y < withAngle[startIndex].y ||
                    (withAngle[i].y === withAngle[startIndex].y && withAngle[i].x < withAngle[startIndex].x)
                ) {
                    startIndex = i;
                }
            }

            const ordered = [];
            for (let i = 0; i < withAngle.length; i++) {
                const idx = (startIndex + i) % withAngle.length;
                ordered.push({ x: withAngle[idx].x, y: withAngle[idx].y });
            }

            return ordered;
        }

        function getObbCenter(points) {
            const cx = points.reduce((sum, p) => sum + p.x, 0) / points.length;
            const cy = points.reduce((sum, p) => sum + p.y, 0) / points.length;
            return { x: cx, y: cy };
        }

        function rotatePoints(points, center, angleDelta) {
            const cosA = Math.cos(angleDelta);
            const sinA = Math.sin(angleDelta);
            return points.map(p => {
                const dx = p.x - center.x;
                const dy = p.y - center.y;
                return {
                    x: center.x + dx * cosA - dy * sinA,
                    y: center.y + dx * sinA + dy * cosA
                };
            });
        }

        function setUnsavedChanges(value) {
            hasUnsavedChanges = value;
        }

        function parseLabelData(content) {
            if (!content || content.trim() === '') return [];

            const lines = content.trim().split('\n');
            return lines.map(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length < 5) return null;

                if (parts.length >= 9) {
                    const points = [];
                    for (let i = 1; i < 9; i += 2) {
                        points.push({ x: parseFloat(parts[i]), y: parseFloat(parts[i + 1]) });
                    }
                    const ordered = orderPointsClockwiseFromTopLeft(points);
                    return {
                        type: 'obb',
                        class: parseInt(parts[0]),
                        points: ordered
                    };
                }

                return {
                    type: 'bbox',
                    class: parseInt(parts[0]),
                    x: parseFloat(parts[1]),
                    y: parseFloat(parts[2]),
                    w: parseFloat(parts[3]),
                    h: parseFloat(parts[4])
                };
            }).filter(a => a !== null);
        }

        function setupCanvas() {
            // Set canvas internal resolution to match container size
            const container = document.querySelector('.canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Calculate base scale to fit image to canvas (fill at least one dimension)
            const scaleX = canvas.width / image.width;
            const scaleY = canvas.height / image.height;
            baseScale = Math.min(scaleX, scaleY);

            document.getElementById('imageSize').textContent = `${image.width} x ${image.height}`;
            viewScale = 1;
            viewOffsetX = 0;
            viewOffsetY = 0;
            updateMouseCanvasPointFromClient();
            draw();
        }

        function draw() {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Calculate total scale and centering offset
            const totalScale = baseScale * viewScale;
            const imageWidth = image.width * totalScale;
            const imageHeight = image.height * totalScale;
            const centerX = (canvas.width - imageWidth) / 2;
            const centerY = (canvas.height - imageHeight) / 2;

            // Apply transform: translate to center + pan, then scale, then draw image at origin
            ctx.translate(centerX + viewOffsetX, centerY + viewOffsetY);
            ctx.scale(totalScale, totalScale);
            ctx.drawImage(image, 0, 0);

            // Draw annotations (now in image coordinate space)
            annotations.forEach((ann, idx) => {
                const isSelected = selectedAnnotation === idx;
                const color = getClassColor(ann.class);

                if (ann.type === 'obb') {
                    const points = ann.points.map(p => ({
                        x: p.x * image.width,
                        y: p.y * image.height
                    }));

                    ctx.strokeStyle = color;
                    ctx.lineWidth = (isSelected ? 3 : 2) / totalScale;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Draw label
                    const label = CLASSES[ann.class] || `class_${ann.class}`;
                    const labelPoint = points.reduce((acc, p) => {
                        if (p.y < acc.y || (p.y === acc.y && p.x < acc.x)) return p;
                        return acc;
                    }, points[0]);
                    ctx.fillStyle = color;
                    ctx.font = `${14 / totalScale}px monospace`;
                    const textWidth = ctx.measureText(label).width;
                    const labelHeight = 20 / totalScale;
                    const labelPadding = 8 / totalScale;
                    ctx.fillRect(labelPoint.x, labelPoint.y - labelHeight, textWidth + labelPadding, labelHeight);
                    ctx.fillStyle = '#000';
                    ctx.fillText(label, labelPoint.x + 4 / totalScale, labelPoint.y - 6 / totalScale);

                    if (isSelected) {
                        const handleSize = 8 / totalScale;
                        ctx.fillStyle = color;
                        points.forEach((p) => {
                            ctx.fillRect(p.x - handleSize / 2, p.y - handleSize / 2, handleSize, handleSize);
                        });

                        const topMid = {
                            x: (points[0].x + points[1].x) / 2,
                            y: (points[0].y + points[1].y) / 2
                        };
                        const edgeDx = points[1].x - points[0].x;
                        const edgeDy = points[1].y - points[0].y;
                        let normal = { x: edgeDy, y: -edgeDx };
                        const center = points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                        center.x /= points.length;
                        center.y /= points.length;
                        const toCenter = { x: center.x - topMid.x, y: center.y - topMid.y };
                        if (normal.x * toCenter.x + normal.y * toCenter.y > 0) {
                            normal.x *= -1;
                            normal.y *= -1;
                        }
                        const normalLen = Math.hypot(normal.x, normal.y) || 1;
                        normal.x /= normalLen;
                        normal.y /= normalLen;
                        const handleOffset = 24 / totalScale;
                        const rotHandle = {
                            x: topMid.x + normal.x * handleOffset,
                            y: topMid.y + normal.y * handleOffset
                        };

                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2 / totalScale;
                        ctx.beginPath();
                        ctx.moveTo(topMid.x, topMid.y);
                        ctx.lineTo(rotHandle.x, rotHandle.y);
                        ctx.stroke();

                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.arc(rotHandle.x, rotHandle.y, 6 / totalScale, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                } else {
                    const x = (ann.x - ann.w / 2) * image.width;
                    const y = (ann.y - ann.h / 2) * image.height;
                    const w = ann.w * image.width;
                    const h = ann.h * image.height;

                    // Draw box (scale line width inversely to keep constant visual size)
                    ctx.strokeStyle = color;
                    ctx.lineWidth = (isSelected ? 3 : 2) / totalScale;
                    ctx.strokeRect(x, y, w, h);

                    // Draw label
                    ctx.fillStyle = color;
                    ctx.font = `${14 / totalScale}px monospace`;
                    const label = CLASSES[ann.class] || `class_${ann.class}`;
                    const textWidth = ctx.measureText(label).width;
                    const labelHeight = 20 / totalScale;
                    const labelPadding = 8 / totalScale;
                    ctx.fillRect(x, y - labelHeight, textWidth + labelPadding, labelHeight);
                    ctx.fillStyle = '#000';
                    ctx.fillText(label, x + 4 / totalScale, y - 6 / totalScale);

                    // Draw handles if selected
                    if (isSelected) {
                        const handleSize = 8 / totalScale;
                        ctx.fillStyle = color;
                        [[x, y], [x + w, y], [x, y + h], [x + w, y + h]].forEach(([hx, hy]) => {
                            ctx.fillRect(hx - handleSize / 2, hy - handleSize / 2, handleSize, handleSize);
                        });
                    }
                }
            });

            // Draw current box being drawn
            if (isDrawing && drawStart && currentBox) {
                ctx.strokeStyle = getClassColor(selectedClass);
                ctx.lineWidth = 2 / totalScale;
                ctx.setLineDash([5 / totalScale, 5 / totalScale]);
                ctx.strokeRect(currentBox.x, currentBox.y, currentBox.w, currentBox.h);
                ctx.setLineDash([]);
            }

            if (isCreatingObb && obbCreatePoints.length > 0) {
                const color = getClassColor(selectedClass);
                const points = obbCreatePoints.map(p => ({
                    x: p.x * image.width,
                    y: p.y * image.height
                }));
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 / totalScale;
                ctx.setLineDash([6 / totalScale, 6 / totalScale]);
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                if (obbPreviewPoint) {
                    ctx.lineTo(obbPreviewPoint.x * image.width, obbPreviewPoint.y * image.height);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = color;
                const handleSize = 8 / totalScale;
                points.forEach((p) => {
                    ctx.fillRect(p.x - handleSize / 2, p.y - handleSize / 2, handleSize, handleSize);
                });
            }

            if (showCrosshair && mouseCanvasPoint) {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(mouseCanvasPoint.x, 0);
                ctx.lineTo(mouseCanvasPoint.x, canvas.height);
                ctx.moveTo(0, mouseCanvasPoint.y);
                ctx.lineTo(canvas.width, mouseCanvasPoint.y);
                ctx.stroke();
            }
        }

        function getCanvasPoint(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            return { x, y };
        }

        // Convert mouse coordinates from display space to image coordinate space
        function getCanvasCoordinates(e) {
            const point = getCanvasPoint(e);
            const totalScale = baseScale * viewScale;
            const imageWidth = image.width * totalScale;
            const imageHeight = image.height * totalScale;
            const centerX = (canvas.width - imageWidth) / 2;
            const centerY = (canvas.height - imageHeight) / 2;

            // Convert from canvas space to image space
            const x = (point.x - centerX - viewOffsetX) / totalScale;
            const y = (point.y - centerY - viewOffsetY) / totalScale;
            return { x, y };
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('mouseenter', () => {
                showCrosshair = true;
                updateMouseCanvasPointFromClient();
                draw();
            });
            canvas.addEventListener('mouseleave', () => {
                showCrosshair = false;
                mouseCanvasPoint = null;
                draw();
            });
            canvas.addEventListener('wheel', handleCanvasWheel, { passive: false });
            canvas.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('mousemove', (event) => {
                lastMouseClient = { x: event.clientX, y: event.clientY };
            });

            // Handle window resize to keep image filling the container
            window.addEventListener('resize', () => {
                updateCanvasDisplaySize();
                updateMouseCanvasPointFromClient();
                draw();
            });

            window.addEventListener('beforeunload', (event) => {
                if (!hasUnsavedChanges) {
                    return;
                }
                event.preventDefault();
                event.returnValue = '';
            });
        }

        function updateCanvasDisplaySize() {
            if (!image) {
                return;
            }

            // Update canvas internal resolution to match container size
            const container = document.querySelector('.canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Recalculate base scale to fit image to canvas
            const scaleX = canvas.width / image.width;
            const scaleY = canvas.height / image.height;
            baseScale = Math.min(scaleX, scaleY);
        }

        function updateMouseCanvasPointFromClient() {
            if (!lastMouseClient) {
                return;
            }
            const rect = canvas.getBoundingClientRect();
            const inside = lastMouseClient.x >= rect.left &&
                lastMouseClient.x <= rect.right &&
                lastMouseClient.y >= rect.top &&
                lastMouseClient.y <= rect.bottom;
            showCrosshair = inside;
            if (!inside) {
                mouseCanvasPoint = null;
                return;
            }
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseCanvasPoint = {
                x: (lastMouseClient.x - rect.left) * scaleX,
                y: (lastMouseClient.y - rect.top) * scaleY
            };
        }

        function handleMouseDown(e) {
            if (e.button === 2) {
                const point = getCanvasPoint(e);
                isPanning = true;
                panStart = {
                    x: point.x,
                    y: point.y,
                    offsetX: viewOffsetX,
                    offsetY: viewOffsetY
                };
                return;
            }

            if (e.button !== 0) {
                return;
            }

            const { x, y } = getCanvasCoordinates(e);

            // Check if clicking on a handle
            if (selectedAnnotation !== null) {
                const ann = annotations[selectedAnnotation];
                const handle = getHandleAt(ann, x, y);
                if (handle) {
                    historySnapshot = captureState();
                    if (handle.type === 'obb-rotate') {
                        isRotating = true;
                        const center = handle.center;
                        rotateState = {
                            center,
                            startAngle: Math.atan2(y - center.y, x - center.x),
                            startPoints: ann.points.map(p => ({ x: p.x, y: p.y }))
                        };
                    } else {
                        isDragging = true;
                        dragHandle = handle;
                    }
                    return;
                }
            }

            if (defaultAnnotationType === 'obb') {
                const clickedIdx = getAnnotationAt(x, y);
                if (clickedIdx !== null) {
                    selectedAnnotation = clickedIdx;
                    updateUI();
                    updateClassSelector();
                    draw();
                    return;
                }

                addObbPoint(x, y);
                return;
            }

            // Check if clicking on an annotation
            const clickedIdx = getAnnotationAt(x, y);
            if (clickedIdx !== null) {
                pendingSelection = clickedIdx;
                isDrawing = true;
                drawStart = { x, y };
                currentBox = { x, y, w: 0, h: 0 };
                updateClassSelector();
                return;
            }

            // Start drawing new annotation
            selectedAnnotation = null;
            lastHitIndices = [];
            lastHitPoint = null;
            isDrawing = true;
            drawStart = { x, y };
            currentBox = { x, y, w: 0, h: 0 };
            updateClassSelector();
        }

        function handleMouseMove(e) {
            if (isPanning && panStart) {
                const point = getCanvasPoint(e);
                viewOffsetX = panStart.offsetX + (point.x - panStart.x);
                viewOffsetY = panStart.offsetY + (point.y - panStart.y);
                mouseCanvasPoint = point;
                draw();
                return;
            }

            const { x, y } = getCanvasCoordinates(e);
            mouseCanvasPoint = getCanvasPoint(e);

            if (isRotating && selectedAnnotation !== null && rotateState) {
                const ann = annotations[selectedAnnotation];
                const angle = Math.atan2(y - rotateState.center.y, x - rotateState.center.x);
                const delta = angle - rotateState.startAngle;
                const centerNorm = { x: rotateState.center.x / image.width, y: rotateState.center.y / image.height };
                ann.points = rotatePoints(rotateState.startPoints, centerNorm, delta);
                draw();
            } else if (isDragging && selectedAnnotation !== null) {
                const ann = annotations[selectedAnnotation];
                resizeAnnotation(ann, dragHandle, x, y);
                draw();
            } else if (isCreatingObb) {
                obbPreviewPoint = { x: x / image.width, y: y / image.height };
                draw();
            } else if (isDrawing) {
                currentBox.w = x - drawStart.x;
                currentBox.h = y - drawStart.y;
                draw();
            } else if (showCrosshair) {
                draw();
            }
        }

        function handleMouseUp(e) {
            if (isPanning) {
                isPanning = false;
                panStart = null;
                return;
            }

            if (isRotating) {
                isRotating = false;
                rotateState = null;
                recordHistory(historySnapshot);
                historySnapshot = null;
                setUnsavedChanges(true);
                updateUI();
            } else if (isDragging) {
                isDragging = false;
                dragHandle = null;
                recordHistory(historySnapshot);
                historySnapshot = null;
                setUnsavedChanges(true);
                updateUI();
            } else if (isDrawing) {
                const { x, y } = getCanvasCoordinates(e);

                const w = Math.abs(x - drawStart.x);
                const h = Math.abs(y - drawStart.y);

                // Only create if box is big enough
                if (w > 10 && h > 10) {
                    const prevState = captureState();
                    const x1 = Math.min(drawStart.x, x);
                    const y1 = Math.min(drawStart.y, y);

                    if (defaultAnnotationType === 'obb') {
                        const points = [
                            { x: x1 / image.width, y: y1 / image.height },
                            { x: (x1 + w) / image.width, y: y1 / image.height },
                            { x: (x1 + w) / image.width, y: (y1 + h) / image.height },
                            { x: x1 / image.width, y: (y1 + h) / image.height }
                        ];
                        annotations.push({
                            type: 'obb',
                            class: selectedClass,
                            points: orderPointsClockwiseFromTopLeft(points)
                        });
                    } else {
                        const centerX = (x1 + w / 2) / image.width;
                        const centerY = (y1 + h / 2) / image.height;
                        const normW = w / image.width;
                        const normH = h / image.height;

                        annotations.push({
                            type: 'bbox',
                            class: selectedClass,
                            x: centerX,
                            y: centerY,
                            w: normW,
                            h: normH
                        });
                    }

                    recordHistory(prevState);
                    setUnsavedChanges(true);
                    updateUI();
                    pendingSelection = null;
                } else if (pendingSelection !== null) {
                    const hitIndices = getAnnotationsAtAll(x, y);
                    if (hitIndices.length > 0) {
                        const pointMatches = lastHitPoint &&
                            Math.abs(lastHitPoint.x - x) <= 5 &&
                            Math.abs(lastHitPoint.y - y) <= 5 &&
                            arraysEqual(hitIndices, lastHitIndices);
                        if (pointMatches) {
                            lastHitCycle = (lastHitCycle + 1) % hitIndices.length;
                        } else {
                            lastHitCycle = 0;
                        }
                        selectedAnnotation = hitIndices[lastHitCycle];
                        lastHitIndices = hitIndices;
                        lastHitPoint = { x, y };
                    } else {
                        selectedAnnotation = pendingSelection;
                    }
                    updateUI();
                    updateClassSelector();
                }

                isDrawing = false;
                drawStart = null;
                currentBox = null;
                pendingSelection = null;
                draw();
            }
        }

        function handleCanvasWheel(e) {
            e.preventDefault();

            const zoomFactor = Math.exp(-e.deltaY * 0.0015);
            const nextScale = Math.min(5, Math.max(0.2, viewScale * zoomFactor));
            if (nextScale === viewScale) {
                return;
            }

            // Get mouse position in canvas coordinates
            const point = getCanvasPoint(e);

            // Calculate current mouse position in image space
            const totalScale = baseScale * viewScale;
            const imageWidth = image.width * totalScale;
            const imageHeight = image.height * totalScale;
            const centerX = (canvas.width - imageWidth) / 2;
            const centerY = (canvas.height - imageHeight) / 2;
            const imageX = (point.x - centerX - viewOffsetX) / totalScale;
            const imageY = (point.y - centerY - viewOffsetY) / totalScale;

            // Update scale
            viewScale = nextScale;

            // Calculate new total scale and centering
            const newTotalScale = baseScale * viewScale;
            const newImageWidth = image.width * newTotalScale;
            const newImageHeight = image.height * newTotalScale;
            const newCenterX = (canvas.width - newImageWidth) / 2;
            const newCenterY = (canvas.height - newImageHeight) / 2;

            // Adjust pan offset so the image point under the mouse stays under the mouse
            viewOffsetX = point.x - newCenterX - imageX * newTotalScale;
            viewOffsetY = point.y - newCenterY - imageY * newTotalScale;

            draw();
        }

        function handleKeyDown(e) {
            // Disable hotkeys when typing in input fields
            const activeElement = document.activeElement;
            const isTyping = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.isContentEditable
            );

            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault();
                saveLabels(true);
                return;
            }

            // Allow Delete/Backspace in inputs
            if (isTyping && (e.key === 'Delete' || e.key === 'Backspace')) {
                return; // Let the input handle it
            }

            // Disable all other hotkeys when typing
            if (isTyping) {
                return;
            }

            if (e.key === 'Escape' && isCreatingObb) {
                e.preventDefault();
                clearObbCreation();
                draw();
                return;
            }

            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                if (e.shiftKey) {
                    redoAction();
                } else {
                    undoAction();
                }
                return;
            }

            // Delete annotation
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (selectedAnnotation !== null) {
                    e.preventDefault();
                    deleteAnnotation(selectedAnnotation);
                }
            }

            // Switch class with W/S keys
            if (e.key === 'w' || e.key === 'W') {
                e.preventDefault();
                if (selectedAnnotation !== null) {
                    // Change class of selected annotation
                    const currentClass = annotations[selectedAnnotation].class;
                    const newClass = (currentClass - 1 + CLASSES.length) % CLASSES.length;
                    changeAnnotationClass(selectedAnnotation, newClass);
                } else {
                    // Change selected class for new annotations
                    selectedClass = (selectedClass - 1 + CLASSES.length) % CLASSES.length;
                    updateClassSelector();
                }
            } else if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                if (selectedAnnotation !== null) {
                    // Change class of selected annotation
                    const currentClass = annotations[selectedAnnotation].class;
                    const newClass = (currentClass + 1) % CLASSES.length;
                    changeAnnotationClass(selectedAnnotation, newClass);
                } else {
                    // Change selected class for new annotations
                    selectedClass = (selectedClass + 1) % CLASSES.length;
                    updateClassSelector();
                }
            }

            // Navigate between images with arrow keys or A/D keys
            if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                previousImage();
            } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                nextImage();
            }
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > point.y) !== (yj > point.y)) &&
                    (point.x < (xj - xi) * (point.y - yi) / (yj - yi + 1e-12) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function getAnnotationAt(x, y) {
            for (let i = annotations.length - 1; i >= 0; i--) {
                const ann = annotations[i];
                if (ann.type === 'obb') {
                    const polygon = ann.points.map(p => ({
                        x: p.x * image.width,
                        y: p.y * image.height
                    }));
                    if (isPointInPolygon({ x, y }, polygon)) {
                        return i;
                    }
                } else {
                    const ax = (ann.x - ann.w / 2) * image.width;
                    const ay = (ann.y - ann.h / 2) * image.height;
                    const aw = ann.w * image.width;
                    const ah = ann.h * image.height;

                    if (x >= ax && x <= ax + aw && y >= ay && y <= ay + ah) {
                        return i;
                    }
                }
            }
            return null;
        }

        function getAnnotationsAtAll(x, y) {
            const hits = [];
            for (let i = annotations.length - 1; i >= 0; i--) {
                const ann = annotations[i];
                if (ann.type === 'obb') {
                    const polygon = ann.points.map(p => ({
                        x: p.x * image.width,
                        y: p.y * image.height
                    }));
                    if (isPointInPolygon({ x, y }, polygon)) {
                        hits.push(i);
                    }
                } else {
                    const ax = (ann.x - ann.w / 2) * image.width;
                    const ay = (ann.y - ann.h / 2) * image.height;
                    const aw = ann.w * image.width;
                    const ah = ann.h * image.height;

                    if (x >= ax && x <= ax + aw && y >= ay && y <= ay + ah) {
                        hits.push(i);
                    }
                }
            }
            return hits;
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }

        function getHandleAt(ann, x, y) {
            const totalScale = baseScale * viewScale;
            const handleSize = 16 / totalScale;

            if (ann.type === 'obb') {
                const points = ann.points.map(p => ({
                    x: p.x * image.width,
                    y: p.y * image.height
                }));
                const topMid = {
                    x: (points[0].x + points[1].x) / 2,
                    y: (points[0].y + points[1].y) / 2
                };
                const edgeDx = points[1].x - points[0].x;
                const edgeDy = points[1].y - points[0].y;
                let normal = { x: edgeDy, y: -edgeDx };
                const center = points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                center.x /= points.length;
                center.y /= points.length;
                const toCenter = { x: center.x - topMid.x, y: center.y - topMid.y };
                if (normal.x * toCenter.x + normal.y * toCenter.y > 0) {
                    normal.x *= -1;
                    normal.y *= -1;
                }
                const normalLen = Math.hypot(normal.x, normal.y) || 1;
                normal.x /= normalLen;
                normal.y /= normalLen;
                const handleOffset = 24 / totalScale;
                const rotHandle = {
                    x: topMid.x + normal.x * handleOffset,
                    y: topMid.y + normal.y * handleOffset
                };
                if (Math.hypot(x - rotHandle.x, y - rotHandle.y) < handleSize) {
                    const centerNorm = getObbCenter(ann.points);
                    return {
                        type: 'obb-rotate',
                        center: { x: centerNorm.x * image.width, y: centerNorm.y * image.height }
                    };
                }
                for (let i = 0; i < points.length; i++) {
                    const p = points[i];
                    if (Math.abs(x - p.x) < handleSize && Math.abs(y - p.y) < handleSize) {
                        return { type: 'obb', index: i };
                    }
                }
                return null;
            }

            const ax = (ann.x - ann.w / 2) * image.width;
            const ay = (ann.y - ann.h / 2) * image.height;
            const aw = ann.w * image.width;
            const ah = ann.h * image.height;

            const handles = [
                { name: 'tl', x: ax, y: ay },
                { name: 'tr', x: ax + aw, y: ay },
                { name: 'bl', x: ax, y: ay + ah },
                { name: 'br', x: ax + aw, y: ay + ah }
            ];

            for (const handle of handles) {
                if (Math.abs(x - handle.x) < handleSize && Math.abs(y - handle.y) < handleSize) {
                    return { type: 'bbox', name: handle.name };
                }
            }
            return null;
        }

        function resizeAnnotation(ann, handle, mouseX, mouseY) {
            if (ann.type === 'obb' && handle && handle.type === 'obb') {
                const idx = handle.index;
                const nextPoints = ann.points.map(p => ({ x: p.x, y: p.y }));
                nextPoints[idx] = { x: mouseX / image.width, y: mouseY / image.height };
                ann.points = nextPoints;
                return;
            }

            if (!handle || handle.type !== 'bbox') {
                return;
            }

            const centerX = ann.x * image.width;
            const centerY = ann.y * image.height;
            const halfW = ann.w * image.width / 2;
            const halfH = ann.h * image.height / 2;

            let x1 = centerX - halfW;
            let y1 = centerY - halfH;
            let x2 = centerX + halfW;
            let y2 = centerY + halfH;

            switch (handle.name) {
                case 'tl':
                    x1 = mouseX;
                    y1 = mouseY;
                    break;
                case 'tr':
                    x2 = mouseX;
                    y1 = mouseY;
                    break;
                case 'bl':
                    x1 = mouseX;
                    y2 = mouseY;
                    break;
                case 'br':
                    x2 = mouseX;
                    y2 = mouseY;
                    break;
            }

            const newCenterX = (x1 + x2) / 2;
            const newCenterY = (y1 + y2) / 2;
            const newW = Math.abs(x2 - x1);
            const newH = Math.abs(y2 - y1);

            ann.x = newCenterX / image.width;
            ann.y = newCenterY / image.height;
            ann.w = newW / image.width;
            ann.h = newH / image.height;
        }

        function deleteAnnotation(idx) {
            const prevState = captureState();
            annotations.splice(idx, 1);
            recordHistory(prevState);
            selectedAnnotation = null;
            setUnsavedChanges(true);
            updateUI();
            draw();
        }

        function changeAnnotationClass(idx, newClass) {
            const prevState = captureState();
            annotations[idx].class = newClass;
            recordHistory(prevState);
            setUnsavedChanges(true);
            updateUI();
            draw();
        }

        function addObbPoint(x, y) {
            if (!image) {
                return;
            }
            const point = { x: x / image.width, y: y / image.height };
            if (obbCreatePoints.length === 0) {
                isCreatingObb = true;
            }
            obbCreatePoints.push(point);
            obbPreviewPoint = null;

            if (obbCreatePoints.length === 4) {
                const prevState = captureState();
                const ordered = orderPointsClockwiseFromTopLeft(obbCreatePoints);
                annotations.push({
                    type: 'obb',
                    class: selectedClass,
                    points: ordered
                });
                recordHistory(prevState);
                setUnsavedChanges(true);
                updateUI();
                clearObbCreation();
            }
            draw();
        }

        function clearObbCreation() {
            isCreatingObb = false;
            obbCreatePoints = [];
            obbPreviewPoint = null;
        }

        function updateUI() {
            const list = document.getElementById('annotationsList');
            list.innerHTML = '';

            annotations.forEach((ann, idx) => {
                const item = document.createElement('div');
                item.className = 'annotation-item';
                if (selectedAnnotation === idx) {
                    item.classList.add('selected');
                }

                const info = document.createElement('div');
                info.className = 'annotation-info';

                const className = document.createElement('div');
                className.className = 'annotation-class';
                className.textContent = CLASSES[ann.class] || `class_${ann.class}`;
                className.style.color = getClassColor(ann.class);

                const coords = document.createElement('div');
                coords.className = 'annotation-coords';
                if (ann.type === 'obb') {
                    const coordText = ann.points
                        .map(p => `${p.x.toFixed(3)},${p.y.toFixed(3)}`)
                        .join(' ');
                    coords.textContent = `obb: ${coordText}`;
                } else {
                    coords.textContent = `x:${ann.x.toFixed(3)} y:${ann.y.toFixed(3)} w:${ann.w.toFixed(3)} h:${ann.h.toFixed(3)}`;
                }

                info.appendChild(className);
                info.appendChild(coords);

                const actions = document.createElement('div');
                actions.className = 'annotation-actions';

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-small btn-danger';
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteAnnotation(idx);
                };

                actions.appendChild(deleteBtn);

                item.appendChild(info);
                item.appendChild(actions);

                item.onclick = () => {
                    selectedAnnotation = idx;
                    updateUI();
                    updateClassSelector();
                    draw();
                };

                list.appendChild(item);
            });

            document.getElementById('annotationCount').textContent = annotations.length;
            updateClassSelector();
        }

        function cloneAnnotations(source) {
            return source.map(ann => {
                if (ann.type === 'obb') {
                    return {
                        type: 'obb',
                        class: ann.class,
                        points: ann.points.map(p => ({ x: p.x, y: p.y }))
                    };
                }
                return {
                    type: 'bbox',
                    class: ann.class,
                    x: ann.x,
                    y: ann.y,
                    w: ann.w,
                    h: ann.h
                };
            });
        }

        function captureState() {
            return {
                annotations: cloneAnnotations(annotations),
                selectedAnnotation,
                selectedClass
            };
        }

        function restoreState(state) {
            annotations = cloneAnnotations(state.annotations);
            selectedAnnotation = state.selectedAnnotation;
            selectedClass = state.selectedClass;
            if (selectedAnnotation !== null && selectedAnnotation >= annotations.length) {
                selectedAnnotation = null;
            }
            setUnsavedChanges(true);
            updateUI();
            draw();
        }

        function annotationsEqual(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                const annA = a[i];
                const annB = b[i];
                if (annA.type !== annB.type || annA.class !== annB.class) {
                    return false;
                }
                if (annA.type === 'obb') {
                    if (annA.points.length !== annB.points.length) {
                        return false;
                    }
                    for (let j = 0; j < annA.points.length; j++) {
                        if (annA.points[j].x !== annB.points[j].x || annA.points[j].y !== annB.points[j].y) {
                            return false;
                        }
                    }
                } else {
                    if (
                        annA.x !== annB.x ||
                        annA.y !== annB.y ||
                        annA.w !== annB.w ||
                        annA.h !== annB.h
                    ) {
                        return false;
                    }
                }
            }
            return true;
        }

        function recordHistory(prevState) {
            if (!prevState) {
                return;
            }
            if (annotationsEqual(prevState.annotations, annotations)) {
                return;
            }
            undoStack.push(prevState);
            if (undoStack.length > HISTORY_LIMIT) {
                undoStack.shift();
            }
            redoStack = [];
        }

        function undoAction() {
            if (undoStack.length === 0) {
                return;
            }
            const currentState = captureState();
            const prevState = undoStack.pop();
            redoStack.push(currentState);
            restoreState(prevState);
            showStatus('Undo');
        }

        function redoAction() {
            if (redoStack.length === 0) {
                return;
            }
            const currentState = captureState();
            const nextState = redoStack.pop();
            undoStack.push(currentState);
            restoreState(nextState);
            showStatus('Redo');
        }

        async function saveLabels(showMessage = true) {
            try {
                // Prevent saving if no label path is available
                if (!currentLabelPath) return;

                if (showMessage) showStatus('Saving labels...');

                // Convert annotations to YOLO format
                const yoloContent = annotations.map(ann => {
                    if (ann.type === 'obb') {
                        const ordered = orderPointsClockwiseFromTopLeft(ann.points);
                        const coords = ordered
                            .map(p => `${p.x.toFixed(6)} ${p.y.toFixed(6)}`)
                            .join(' ');
                        return `${ann.class} ${coords}`;
                    }
                    return `${ann.class} ${ann.x.toFixed(6)} ${ann.y.toFixed(6)} ${ann.w.toFixed(6)} ${ann.h.toFixed(6)}`;
                }).join('\n');

                // Build save request based on format
                const requestBody = {
                    content: yoloContent
                };

                if (basePath && currentLabelPath) {
                    requestBody.basePath = basePath;
                    requestBody.relativeLabelPath = currentLabelPath;
                } else {
                    requestBody.labelPath = currentLabelPath;
                }

                const response = await fetch('/api/label-editor/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to save labels');
                }

                if (showMessage) {
                    showStatus('Labels saved successfully!');
                    setTimeout(() => showStatus('Ready'), 2000);
                }

                // Update label cache for current image
                const currentImage = imageList[currentImageIndex];
                const classes = [...new Set(annotations.map(ann => ann.class))];
                labelCache[currentImage] = {
                    classes: classes,
                    count: annotations.length
                };
                setUnsavedChanges(false);

            } catch (error) {
                showError(error.message);
            }
        }

        function showStatus(message) {
            document.getElementById('statusBar').textContent = message;
            document.getElementById('statusBar').style.color = '#aaa';
        }

        function showError(message) {
            // Hide loading and canvas
            document.getElementById('loading').style.display = 'none';
            document.getElementById('canvas').style.display = 'none';

            // Show error message
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = `Error: ${message}`;
            errorEl.style.display = 'block';

            document.getElementById('statusBar').textContent = `Error: ${message}`;
            document.getElementById('statusBar').style.color = '#dc3545';
        }

        // Initialize on load
        init();
    </script>
</body>

</html>
